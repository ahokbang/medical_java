package p0625;

public class C0625_01 {

	public static void main(String[] args) {
		// 상속, 오버라이딩

		Circle c1 = new Circle(); // 기본생성자 호출
		System.out.println("반지름 : "+c1.r);
		
		// 원의 중심축을 출력하시오.
//		System.out.println("원점 : "+c1.center); // 주소값		
		System.out.printf("원점 : (%d, %d)\n",c1.center.x, c1.center.y);
		// c1, center 모두 참조변수.       참조변수명.참조변수명.변수명
		
		Circle c2 = new Circle(new Point(150,150), 50);
		System.out.printf("좌표 : (%d, %d)\n",c2.center.x, c2.center.y);
		
		
		// Circle c2 = new Circle(new Point(150,150), 50);를 아래와 객체 선언해서 작성 가능하지만 사용하지 않음.
//		Point p = new Point(150,150); // 객체선언
//		Circle c2 = new Circle(p, 50); 
		
		// draw()
//		System.out.println(c2.draw()); // error, draw()에 이미 print가 있음 
		c2.draw();

		
		int[] a = {1, 2, 3}; // 배열 선언, int이기 때문에 int를 넣어주었어.
//		Point[] p = {1,2,3,}; // point는 객체
		Point p1 = new Point(100, 100);
		Point p2 = new Point(140, 50);
		Point p3 = new Point(200, 100);
		
		Point[] p = {p1, p2, p3,}; // point는 객체이기 때문에 객체를 넣어햐 함.
		Triangle t1 = new Triangle(p);
		
		Point[] p4 = {new Point(100,100), new Point(140, 50), new Point(200,100)};
		Triangle t2 = new Triangle(p4);
		
		Triangle t3 = new Triangle(new Point(0,0), new Point(100,100), new Point(50,50));
		
		
		
		
//		Point3D p = new Point3D(); // 객체선언
//		p.x = 100;
//		System.out.println("p.x : "+p.x);
//		
//		Point p2 = new Point(); // 포함관계 = 객체선언 

	}

}

/* [객체지향개념 2]
 * 1. 상속
 * 2. 오버라이딩
 * 3. package와 import
 * 4. 제어자
 * 5. 다형성
 * 6. 추상클래스
 * 7. 인터페이스
 * 
 * 1.1 상속의 정의와 장점
 * 상속이란? 많이 사용하지는 않아. 조상이 수정디면 상속받은 모든것이 수정돼. 
 * class 자손클래스 extends 조상클래스 {}
 * - 기존의 클래스를 재사용해서 새로운 클래스는 작성하는 것
 * - 두 클래스를 조상과 자손으로 관계를 맺어주는 것 
 * - 자손은 조상의 모든 멤버를 상속받는다. 생성자, 초기화블럭 제외
 * - 자손의 맴버개수는 조상보다 적을 수 없다. 같거나 많다.
 *
 *1.3 클래스간의 관계 설정하기 - 상속 vs 포함
 * 가능한 한 많은 관계를 맺어주어 재사용성을 높이고 관리하기 쉽게 한다.
 * is-a와 has-a를 가지고 문장을 만들어 본다.
 * 예) 원은 도형이다. : 상속관계
 *    원은 점을 가지고 있다. : 포함관계
 * 
 * 1.4 단일상속
 * - Java는 단일상속만 허용한다(C++은 다중상속 허용).
 * - 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다. 
 * 
 * 1.5 Object 클래스 : 모든 클래스의 최고조상
 * - 조상이 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
 * - 상속계층도의 최상위에는 Object 클래스가 위치한다.
 * - 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다. 
 * toString(), equals(Object obj), hashCode(), ...
 * 
 * 
 * 2.1 오버라이딩 : 같은 메소드, 오버로딩은 다른 메소드.
 * - 조상클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것
 *  => 상속받은 거에서 메소드이름을 같이 쓰는 것. 단 모든 것이 같아야 함. 
 * 
 * 2.2 오버라이딩의 조건
 * - 선언부가 같아야 한다(리턴타입, 이름, 매개변수), 정의된 것만 다름!
 * - 접근제어자를 좁은 범위로 변경할 수 없다.
 *   - 조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 public으로만 변경할 수 있다.
 * - 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 
 * 
 * 2.4 super - 참조변수
 * this : 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있음. 
 *        모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재
 * super : this와 같음. 조상의 멤버와 자신의 멤버를 구별하는 데 사용.
 * 
 * 2.5 super - 조상의 생성자
 * - 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
 * - 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서 조상의 생성자를 호출해야 한다. 
 * - Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 조상의 생성자)를 호출해야 한다. 
 *   그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.  
 * 
 * 3. package와 import : package -> 폴더, import : 위치점을 알려줘
 * 3.1 패키지(package)
 * - 서로 관련된 클래스의 인터페이스 묶음
 * - 클래스가 물리적으로 클래스파일(*.clasS)인 것처럼, 패키지는 물리적으로 폴더이다. 
 *   패키지는 서브패키지를 가질 수 있으며, '.'으로 구분한다.
 * - 클래스의 실제 이름은 패키지명이 포함된 것이다.
 * - rt.jar는 Java ..
 * 
 * 3.2 패키지의 선언
 * - 패키지는 소스파일에 첫번째 문장(주석 제외)으로 단 한번 선언한다.
 * - 하나의 소스파일에 둘 이상의 클래스가 포함된 경우, 모두 같은 패키지에 속하게 된다.
 *   하나의 소스파일에 
 *   
 * 3.3 클래스패스 설정
 * - 클래스패스는 클래스파일(*.class)을 찾는 경로. 구분자는 ';'
 * - 클래스패스에 패키지가 포함딘 폴더나 jar 파일을 나열한다.
 * - 클래스패스가 없으면 자동적으로 현재 폴더가 포함되지만 
 *   클래스패스를 지정할 때는 현대폴더(.)도 함께 추가해주어야 한다.
 * 
 * 3.4 import 문
 * - 사용할 클래스가 속한 패키지를 지정하는 데 사용 
 * - import문을 사용하면 클래스를 ㅏ용할 때 패키지명을 생략할 수 있다. 
 * - hava.lang 패키지의 클래스는
 * 
 * 3.5 import 선언
 * - import문은 컴파일 시에 처리되므로 프로그램의 성능에 아무런 영향을 미치지 않는다.
 * - 이름이 같은 클래스가 속한 두 패지지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.
 * 
 * 
 * 4.1 제어자란?
 * - 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
 * - 제어자는 크게 접근제어자와 그외의 제어자로 나뉜다.
 * 접근데어자 : public, protected, default, private
 * 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
 * 
 * 4.2 static - 클래스의, 공통적인
 * static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
 * 
 * 
 * 
 */
 